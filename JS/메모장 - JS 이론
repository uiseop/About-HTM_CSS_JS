JS는 인터프리팅 언어이고 번거로운 부대 작업이 필요없다는 장점이있다.
(노드같은 자바스크립트 엔진은 분명 JS이긴 하지만, 프로그래머가 개입할 필요 없이 자동으로 이뤄짐)
JS의 장점은 어디서든 쓰인다는것. 거의 항상 브라우저 스크립트 언어의 표준이였고,
노드의 등장으로 이제 브라우저 바깥으로(Back-end)영역을 확장
자바스크립트의 버전 ES5->ES6로 점점 발전할 수 있는 이유 : JS의 동적 성격때문, 최근 브라우저 업데이트 방식 때문이기도 함

원시타입  -> 실제 객체에 값이 저장되지 않음 : 대응하는 원시값에 기능을 제공하는 역할 , 임시로 만들어져서 객체랑 다르게 프로퍼티를 할당해도 undefind로 파괴됨
- 숫자 Number -> 숫자형 데이터를 하나만 갖기로 한 단순한 자바스크립트의 특성 : 고성능 정수 연산이나 정밀한 소수점 연산이 필요한 어플리케이션에선 쓸 수 없음
10진수, 2진수, 8진수, 16진수 네 가지 숫자형 리터럴을 인식 Number.EPSILON, MAX_SAFE_INTEGER, MAX_VALUE, NaN, POSITIVE_INFINITY 등 표현 가능 
자바스크립트의 0.1은 이진 표현으로 나타낼 수 있는 숫자들 사이에 걸쳐있어서 n === 0.3 결과를 처리하지 못해 
=> if(Math.abs(n-0.3) < Number.EPSILON) ==> '느슨하게' 비교함 EPSILON은 매우 작은값임. 거의 0
- 문자열 String -> \역슬레시를 쓰면 특수문자 사용 가능 가령 \" 같은, s.toUpperCase(); : 대문자로 변형
- 불리언
- null
- undefined
- Symbol -> 유일한 토큰을 나타내기 위해 ES6에서 도입한 새 데이터 타입. 심볼은 항상 유일 PK임 : 이런 면에서 객체와 유사
Symbol() 생성자로 만듦 (new 키워드로 시작하지 않아, 대문자로 시작하는 식별자는 new와 함께쓰는게 불문율임)

객체타입 : 유일함, 다른 어떤것과도 일치하지 않음, 여러 가지 값이나 복잡한 값을 나타낼 수 있으며 변할 수 있음
(본질은 컨테이너. 컨테이너의 내용물은 변할 수 있는데 컨테이너는 강철-안변함)
객체의 콘텐츠는 프로퍼티(Property) 혹은 멤버(Member)라고 부름 -> Key 문자열, 심볼이 올 수 있음
객체타입의 참조의 경우 원본이 바뀌면 및에 참조하는 값도 바뀜 -> shallowCopy라고 할 수 있음
delete sam3.speak 처럼 delete를 통해 객체의 멤버를 삭제 가능함 OOP개념 9장에 계속###################
- Array : 파이썬의 list와 같음. 동적으로 할당 가능, 요소 데이터타입을 가리지않음.
- Date : new Date()로 생성 가능 퀴찮아! 구글링 해! d.valueOf()사용하면 1970년1월1일부터 얼마나 지났는지 출력
- RegExp : 정규표현식이래 17장에서################### 설명 가령 이메일 정규표현식같은 /.../안에 표현 ex)/\b[a-z0-9._-]+@[a-z_-]+\b/;
- Map과 WeakMap
- Set과 WeakSet

원시값과 객체값의 참조 Call by Value VS Call by Reference
Value를 매개변수를 통해 참조시키면 변수 자체를 받는것이 아니라 값을 받음. 원래 변수의 값에 변화가 없음
Reference를 매개변수를 통해 참조시키면 객체 자체를 받음. 객체의 내용물은 변할 수 있는데 객체 자체는 변하지 않음
가령 o.message = {다른값} : 변함 , o = {다른값} ==> 객체 자체를 수정하려했기때문에 변하지 않음.

데이터 타입 변환
#숫자로 변환
Number("33.3") --> 33.3
parseInt("16 volts", 10) --> 16 : 뒤에는 기수(몇진수인지 표현)
parseFloat("15.5 kph") --> 15.5 : 뒤에 기수는 default:10

#문자열로 변환
배열경우 const arr = [1,true,"hello"] --> arr.toString() --> "1,true,hello"로 변환 문자열을 쉼표로 연결한 문자열로 변환해줘서 쓸만해


#for..of
일반적인 파이썬의 for i in lst와 같음 : idx를 말고 idx번째 요소를 알고싶을때
#for..in
얘는 그냥 length를 받아오지 않고 키값을 통해 끝까지 탐색한다는 점에서 쓸모가 없어보임

#비교연산자
=== vs == : === 는 일치함, == 는 동등함
일치함은 두 값이 같은 객체, 같은 타입, 같은 값인지를 확인함 !==
동등함은 두 값이 같은 객체, 같은 값인지를 확인 !=
결론 : 타입을 비교하는지 안하는지


#쉼표연산자
쉼표 연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환합니다. 표현식을 하나 이상 실행해야 하지만
 값으로 필요한 것은 마지막 표현식의 결과뿐일 때 쉼표 연산자를 사용
ex) let x = 0, y = 10, z;
z = (x++, y++) ==> z = 10

#ES6에서 새로 도입한 해체 할당.
객체나 배열을 변수로'해체'할 수 있다.
ex) const obj = {b:2, c:3, d:4}  const {a,b,c} = obj 하면 a 는 undefined, b는 2 c는 3으로 나옴
이처럼 객체를 해체시키려면 객체의 프로퍼티 이름이 일치해야 변수로 할당 해체 가능해.
#확산연산자 ...를 이용
ex) let {a,b,...rest} = obj 라고 하면 앞에 2개의 요소는 a,b에 저장하고 나머지는 obj에 저장


#This 키워드
함수 바디 안에는 특별한 읽기 전용값인 this가 있음. this는 일반적으로 객체지향 프로그래밍 개념에 밀접한 연관이 있음. 9장에서 계속...###################
일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있음. 메서드를 호출하면 this는 호출한 메서드를 소유하는 객체가 됨 
ex) const o = { //`는 백틱이라고 함
    name:'Wallet',
    speak(){return `My name is ${this.name}!`} //this를 안붙이고 ${name}이라고만 쓰면 못알아쳐먹음
} this는 o에 묶임
this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호출했느냐에 따라 달라진다는 것을 이해해야한다. 
this가 o에 묶인 이유는 speak가 o의 프로퍼티여서가 아니라 o에서 speak를 호출했기때문임
중첩함수안에서는 의도대로 this가 최상위 객체에 연결되지 않을 수 있어 -> 중첩함수 쓰기 전에 this를 다른 변수에 저장하는 방법을 사용
===> 화살표 함수를 사용하면 이 문제를 해결할 수 있데, 다른 변수에 this를 저장하지 않아도 되나?

#화살표 표기법 Arrow notation
function이라는 단어와 중괄호 숫자를 줄이기 위해 고안된 단축 문법임
1. function을 생략 가능
2. 함수에 매개변수가 단 하나 뿐이라면 ()를 생략할 수 있음
3. 함수 바디가 표현식 하나라면 중괄호와 return문도 생략할 수 있음
값은 표현식의 결과 즉, 표현식의 계산 결과로 메모리에 할당된 값
표현식은 값을 산출하는 구문 ex) 1; 30+10; 'Hello' plus() 처럼 그냥 표현
리터럴은 값을 표기하는 약속된 기호, 문자, 방법 -> 1은 정수 리터럴, 'Hello'는 문자열 리터럴
일반함수와 화살표 함수의 차이점
1. 객체 생성자로 사용할 수 없음
2. arguments 변수도 사용할 수 없음 but ...(확산 연산자)로 대체가능

#call과 apply,bind
&&1.call메서드는 모든 함수에서 사용할 수 있으며, this를 특정 값으로 지정할 수 있음
ex) const bruce = {name : 'Bruce'}
const madeline = {name:"Madeline"}

function greet(){
    return `Hello I'm ${this.name}` // this는 어느 객체와도 연결 안되어있는 상태
}

greet.call(bruce) --> Hello I'm Bruce
greet.call(madeline) --> Hello I'm Madeline 출력 가능

call을 사용하면 this로 사용할 객체를 넘기면서 해당 함수가 주어진 객체의 메서드인것처럼 재활용 가능

function update(birth, occu){
    this.birth = birth
    this.occu = occu
}

update.call(bruce,1949,'singer') --> bruce는 인제 {'name':bruce, 'birth':1949, 'occu':'singer'} 가 됨

&&2.apply는 매개변수를 배열로 받음 --> 매개변수를 배열로 받을 때 유용하겠네, 흔히 최대값, 최소값구할때 사용
update.apply(bruce,[1949,'singer'])
Math.min.apply(null,[2,3,-4,15,7]) --> this값에 null을 쓴 이유는 this와 관계없이 동작하기때문, 무엇을 넘기든 상관x
const newArr = [1940, 'singer']
update.call(bruce,...newArr) 도 apply랑 같은 기능 by 확산연산자를 통해
Math.min(...numArray) --> this값에 뭐를 쓰든 상관x 안써도 상관x니까 call이나 apply를 안씀

&&3.bind는 this값을 묶어주는것!
ex) const updateBruce = update.bind(bruce) --> update의 this는 인제 bruce인거야


